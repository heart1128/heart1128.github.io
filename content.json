{"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2023/03/17/hello-world/"},{"title":"hello","text":"测试一下搭建的环境这是二级标题","link":"/2023/03/17/hello/"},{"title":"right-ref","text":"右值引用1.左值左值即变量 int a = 5， a是左值 2.右值表达式值，临时值，不可被常规引用的值 3.move作用：窃取资源，可以把左值窃取到右值引用中。 如：int &amp;&amp;p = std::move(q) 当存在int &amp;&amp; a= 10; int &amp;&amp; b = a; 会失败，因为a本身是左值，只是类型是右值，使用move可以把a本身转为右值引用进行绑定。 注意：当移动左值之后，源对象可以赋值可以销毁但是不可再使用，因为资源被窃取了。 4. 移动语义 例如深拷贝，需要申请内存再赋值，但是如果使用移动拷贝构造函数，就能省去大量的拷贝代价。fun(fun&amp;&amp; a){} 这就是移动拷贝构造的常规形态。调用：fun b = std::move(a); 使用了移动拷贝，直接将新指针指向，原指针置空即可（也就是浅拷贝），当然原指针在移动后不能再使用，一般是右值。左值使用move()之后，原左值就不能用了。 STL都实现了移动拷贝构造函数，只有实现了移动拷贝构造函数时才能省下拷贝代价。 5.万能引用、引用折叠、完美转发5.1 万能引用 形式：T&amp;&amp; ，其中T是需要被推导类型是万能引用的一个限制，如果没有类型推导T&amp;&amp;形式，&amp;&amp;只代表右值引用 常用：模板推导参数，auto&amp;&amp; 1234567891011// auto推导widget&amp;&amp; val = someWidget; // 这里val是一个右值引用，但是val本身是一个左值auto&amp;&amp; val_1 = val; //auto&amp;&amp; 进行了万能引用，会忽略修饰类型。由val自己本身是左值推导为 widget&amp; val_1 = val 是一个左值引用// 模板参数推导template&lt;typename T&gt;void f(T&amp;&amp; param);f(10); //10是一个右值，传入推导为：T&amp;&amp; 右值引用,推导为int&amp;&amp;int x = 10;f(x); // x是一个左值int&amp; ,传入推导为：T&amp;&amp; &amp; 是一个左值引用，推导为int&amp; 作用：可以同时接受左右值引用，接受哪个就是哪个类型。但是模板类型万能引用传值的时候就有引用折叠的问题。 当T进行推导时，左值引用被推导为T&amp; ，右值引用被推导为T 就会出现左值为T&amp; &amp;&amp;(引用折叠)，右值为T&amp;&amp;。 当实参自身是引用时，使用万能引用时会被去除本身的引用。 如：int &amp;&amp;a = 10; int &amp;b = c; 使用万能引用时就会都变成int&amp;，因为只看a,b自身类型。 有T&amp;&amp;但不是万能引用的情况 12345678910111213141516171819template&lt;classT,classAllocator= allocator&lt;T&gt;&gt;classvector {public:...void push_back(T&amp;&amp; x) //只是移动 ...};template &lt;class T&gt;void vector&lt;T&gt;::push_back(T&amp;&amp; x); //此时的T&amp;&amp;并不是万能引用，因为在vector&lt;T&gt;模板类实例化时，T已经推导了特殊情况template &lt;class T, class Allocator = allocator&lt;T&gt; &gt;class vector {public: ... template &lt;class... Args&gt; void emplace_back(Args&amp;&amp;... args); // deduced parameter types ⇒ type deduction; ... // &amp;&amp; ≡ universal references};这里的参数包不是在vector&lt;T&gt;实例化时确定的，是传入emplace_back()时确定的，所以需要推导，是一个万能引用。 5.2 引用折叠 核心问题：因为c++不支持 “引用的引用“ 由于有右值引用，左值引用，所以会出现四种情况 左左 左右 右右 右左 引用折叠的规则是：只要有左值引用就是左值引用，只有c的情况才是右值引用。 引用折叠发生在&lt;T&amp;&amp;&gt; 、auto&amp;&amp;、typedef中 如： 12Widget&amp;&amp; var1= someWidget; // 此时的var1类型为&amp;&amp;，但是var1本身的类型是左值auto&amp;&amp; var2= var1; //auto&amp;&amp;万能引用发生引用折叠，var1忽略修饰类型&amp;&amp;，按照自身类型&amp; ，推导为auto&amp;&amp; &amp; -&gt; widget&amp; var2 5.3 完美转发 引出问题：一个使用万能引用的模板，传进去左值或者右值引用再转发会出现二义性，没有最初传入的引用类型了 123456789101112131415161718192021222324252627282930void foo(const shape&amp;){ puts(&quot;foo(const shape&amp;)&quot;);}void foo(shape&amp;&amp;){ puts(&quot;foo(shape&amp;&amp;)&quot;);}template&lt;typename T&gt;void bar(T&amp;&amp; s) //万能引用后丢弃自身类型,进入函数之后s在内存中有了位置，现在其实是个左值 T&amp;&amp; &amp;{ foo(std::forward&lt;T&gt;(s)); // forward会保留修饰的类型}intmain() { circle temp; // circle继承shape bar(temp); // 左值传入推导 T&amp;&amp; &amp;-&gt; &amp;左值引用，再转发foo(s)，正常调用foo(const shape&amp;) bar(circle()); // 右值传入推导T&amp;&amp; &amp;&amp; -&gt; &amp;&amp; 右值引用 -&gt; 如果直接foo(s)会丢弃&amp;&amp;，用s自身&amp;类型，又会调用foo(const shape&amp;) // 使用forward之后会保留修饰类型&amp;&amp; -》 调用foo(shape&amp;&amp;)}/*解释：直接右值传参*/void foo(int&amp;&amp; s){}void foo(int&amp; s){}int a = 1;int &amp;b = a;int&amp;&amp; c = 2;foo(b); // 传参忽略&amp;，直接传b，触发foo(int&amp;)foo(c); // 传承忽略&amp;&amp;，直接传c，触发啊foo(int&amp;)foo(std::move(c)); // 保留&amp;&amp;，触发foo(int&amp;&amp;) 5.4 将亡值生命周期的延长 将亡值：xvalue 是指生命周期即将结束的值 纯右值：临时值，不可以取地址。 如： 123result process_shape(const shape&amp;shape1,const shape&amp;shape2) { puts(&quot;process_shape()&quot;);return result(); 这里的result是一个类，继承了shaape，所以析构的时候是从子类开始。 result **&amp;&amp;**r **=** process_shape(circle(), triangle()); 如果一个纯右值被绑定到一个引用上，他的生命周期延长到这个引用一样长。 process_shape返回一个纯右值，这时result的析构就绑定在r上，程序结束时r的生命周期结束才会调用result的析构。 注意：这个规则只对纯右值有用，当result &amp;&amp;r = std::move(process_shape(circle(), triangle()));使用了move之后就不是纯右值了，成了 右值引用。 6. 总结 万能引用的形式 T&amp;&amp; 或者auto&amp;&amp; move()和forward()的本质都是static_cast()的转换，两个比较好的规则是： (1)右值引用进行参数传递时使用move() (2)使用万能引用之后需要原引用类型的转发，使用forward() move()解决的问题：一个本身是左值的右值引用类型变量，再次绑定或者传参到函数时直接传是错了，要使用move把本身变成右值引用。 forward()解决的问题：绑定到万能引用之后会有二义性，再转发到其他函数不会保留本身引用，用Forward可保留原来的引用。 使用大量右值引用的原因是，移动语义不用拷贝，节省空间时间。 参考文章：现代C++之万能引用、完美转发、引用折叠 - 知乎 (zhihu.com)","link":"/2023/03/17/right-ref/"}],"tags":[],"categories":[],"pages":[]}